import functools
import math
from concurrent.futures.thread import ThreadPoolExecutor
from pwn import remote


# n = p * (a^m * p + a^(m - 1) * c + a^(m - 2) * c ... + c)
# n mod c = a^m * p^2 mod c


def proof_of_concept():
    a = 1611925583025917214572256604416391341702149093009008347129358972431466468819463198909170829089411924734533779937908921181057839221359202129269913461050337
    c = 6743823625459653376819839370549366133207070345375180268124026113184217519714406676019811433840884956018902757293922681638596094042535625426988863123518227
    m = 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096
    p = 8859115695691213857462621155924628871443106163758318697979284861611057301150455629291098371365308466977296744708873727411640281031412923862074034888420963
    q = 10075901304860854043163469290629089951444782368613837054401334028451696030532864335251143716478014346668675307563086749932664242036979729800406270188431139
    n = p * q

    assert math.gcd(a, c) == 1

    target = p * p % c
    print(target)
    inv_a = pow(a, -1, c)
    inv = inv_a
    for i in range(10_000):  # local testing suggests this should be in the thousands at most
        p_squared = n * inv % c

        print(p_squared)
        if p_squared == target:
            return

        inv = inv * inv_a % c

    raise ValueError()


def main():
    # Using this set of parameters since factordb has a fully factored entry for c
    a = 9707809084482795388040145298070056590782617660490545179872121920584279110625383625027410352068991893602051929619296143594467969460066608426042221037614513
    c = 6183672508980988930982875172602156422799459851072810252393013985690162944858553327449664208885307241858455195653047045038697266023224748077304066876746531
    m = 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096
    n = 14988679750982088745981887725147290101617074046410019877353239351941153973563965804916517334591833224677115225623687280033741022127304065101939820053833253653672902208720307370885368476539398176500288360709114361865433577893335880418886793819068303996135053288622579795155912048830598990815363085252679450939
    ct = 3576567928935746358423896027959286840462598791892345977864377504023672056847792487199054086700075667171201468577999871382929788378563279398853930180488942621647543047428370410578869531273703674181629533020023981451481226979453954212823735712978779722499388692488962245910790923406878094263450418494731852805

    assert math.gcd(a, c) == 1

    c_factors = [31, 97, 4481, 458921187836206994434905563474867236642690513852918675318329535308795058414139478867516686229884286353374165602959088544842014917897423164836171293]
    assert functools.reduce(lambda x, y: x * y, c_factors, 1) == c

    inv_a = pow(a, -1, c)
    inv = inv_a
    for _ in range(10_000):  # local testing suggests this should be in the thousands at most
        p_squared = n * inv % c

        inv = inv * inv_a % c


if __name__ == '__main__':
    proof_of_concept()
    # main()
