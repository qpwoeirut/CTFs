# Generated by Gemini Pro, doesn't work

#!/usr/bin/env python3

from sympy import symbols, gcd, resultant
from math import gcd as int_gcd

# --- Helper Functions ---

def egcd(a, b):
    """Extended Euclidean Algorithm"""
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modInverse(a, m):
    """Modular Inverse (a^-1 % m)"""
    g, x, y = egcd(a, m)
    if g != 1:
        # This will happen if m is not prime, which is possible.
        # But if m is prime (as per chall.py), g should be 1.
        raise Exception(f'Modular inverse does not exist for {a} and {m}')
    else:
        return x % m

def long_to_bytes_custom(n):
    """Converts a long to bytes, handling n=0"""
    if n < 0:
        raise ValueError("Number must be non-negative")
    # Handle 0 explicitly
    if n == 0:
        return b'\x00'
    byte_length = (n.bit_length() + 7) // 8
    return n.to_bytes(byte_length, byteorder='big')

def S_k(X, k):
    """Generates the polynomial 1 + X + ... + X^(k-1)"""
    # Use the formula (X^k - 1) // (X - 1)
    return (X**k - 1) // (X - 1)

# --- The 6 outputs from the challenge ---
O = [
    1471207943545852478106618608447716459893047706734102352763789322304413594294954078951854930241394509747415,
    1598692736073482992170952603470306867921209728727115430390864029776876148087638761351349854291345381739153,
    7263027854980708582516705896838975362413360736887495919458129587084263748979742208194554859835570092536173,
    1421793811298953348672614691847135074360107904034360298926919347912881575026291936258693160494676689549954,
    7461500488401740536173753018264993398650307817555091262529778478859878439497126612121005384358955488744365,
    7993378969370214846258034508475124464164228761748258400865971489460388035990421363365750583336003815658573
]

X = symbols('X')

print("F 1. Defining polynomials P(X)...")
# P_n(X) = (O_{n+1} - X^n O_n)*S_{n+1}(X) - (O_{n+2} - X^{n+1} O_{n+1})*S_n(X)
# We start n=1 for P1
P1 = (O[1] - X**2 * O[0]) * S_k(X, 3) - (O[2] - X**3 * O[1]) * S_k(X, 2)
# n=2 for P2
P2 = (O[2] - X**3 * O[1]) * S_k(X, 4) - (O[3] - X**4 * O[2]) * S_k(X, 3)
# n=3 for P3
P3 = (O[3] - X**4 * O[2]) * S_k(X, 5) - (O[4] - X**5 * O[3]) * S_k(X, 4)
# n=4 for P4
P4 = (O[4] - X**5 * O[3]) * S_k(X, 6) - (O[5] - X**6 * O[4]) * S_k(X, 5)

print("F 2. Calculating polynomial resultants...")
# The resultant Res(P, Q) is 0 mod m if P and Q share a root mod m.
# We compute resultants for pairs of our polynomials
R12 = resultant(P1, P2)
R23 = resultant(P2, P3)
R34 = resultant(P3, P4)

print("F 3. Calculating integer GCD of resultants to find 'm'...")
# We must cast the SymPy numbers to Python 'int' before using abs() or int_gcd()
r12_int = int(R12)
r23_int = int(R23)
r34_int = int(R34)

# m must be a common divisor of all these resultants.
m = int_gcd(abs(r12_int), int_gcd(abs(r23_int), abs(r34_int)))

# In a CTF, m might be the GCD or a large factor of the GCD.
# Here, m *is* the GCD.
print(f"   [+] Recovered 'm': {m}")

print("\nF 4. Calculating polynomial GCD (mod m) to find 'a'...")
# Now we find the common root 'a' by computing the GCD in Z_m[X]
# SymPy's gcd can take a 'modulus' argument
G_mod_m = gcd(P1, P2, modulus=m)

# Convert to a standard polynomial to extract coefficients
G_poly = G_mod_m.as_poly(X)
coeffs = G_poly.all_coeffs()

# The polynomial will be monic (leading coeff 1), so G_poly = X + d
# The root 'a' is -d.
d = coeffs[1]
a = (-d) % m  # The root 'a' is (-d) mod m
print(f"   [+] Recovered 'a': {a}")

print("\nF 5. Recovering 'c'...")
# O_2 = a^2*O_1 + c*(a+1) (mod m)
# c = (O_2 - a^2*O_1) * (a+1)^-1 (mod m)
a_plus_1_inv = modInverse(a + 1, m)
c = ((O[1] - (a**2 * O[0])) * a_plus_1_inv) % m
print(f"   [+] Recovered 'c': {c}")

print("\nF 6. Recovering the flag...")
# O_1 = a*flag + c (mod m)
# flag = (O_1 - c) * a^-1 (mod m)
a_inv = modInverse(a, m)
flag_long = ((O[0] - c) * a_inv) % m
print(f"   [+] Recovered flag (long): {flag_long}")

# Convert the final number back to bytes
flag_bytes = long_to_bytes_custom(flag_long)

print("\n" + "="*40)
print(f"F The recovered flag is:")
try:
    print(f"F {flag_bytes.decode('utf-8')}")
except UnicodeDecodeError:
    print(f"F (bytes): {flag_bytes}")
print("="*40)