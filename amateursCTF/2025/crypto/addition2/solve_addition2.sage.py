

# This file was *autogenerated* from the file solve_addition2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_11815953932321128728286233763946916083397132728774218853346901896847188062939618033061595326264327830942380514491618514586479068876201765042381540474422687928784286122531623688899920415815956275126678569442393624831728013854407837097172178108695344411448021235738642206171772855890935506373843616183829294338481706967331141381727658274111770236006132024516691250575800075062740745483678936453715236048486953080169036051497290791345433300776845180927261001993504665419670145522848813444443104847339194310622317245742505936802346818589376535066811385405389539543630786953269642690201765952292987472483062982297132627321 = Integer(11815953932321128728286233763946916083397132728774218853346901896847188062939618033061595326264327830942380514491618514586479068876201765042381540474422687928784286122531623688899920415815956275126678569442393624831728013854407837097172178108695344411448021235738642206171772855890935506373843616183829294338481706967331141381727658274111770236006132024516691250575800075062740745483678936453715236048486953080169036051497290791345433300776845180927261001993504665419670145522848813444443104847339194310622317245742505936802346818589376535066811385405389539543630786953269642690201765952292987472483062982297132627321); _sage_const_5552408285910496541614491292546618487277211569377225403191789409528665330891668962031107311064987466753113031830394622471248467736700652061053352988955398236688482161510180819698076352326769666833652868411838404062485515937149953551475970963763214831393011184102640218822580230636796726766349237830849965235421997885866325066652824478670882972960308592442673156948316859355768191060921448605547945438310642985852416679844583683910584162765972403175157909824057369064056749026253300086561085479141352848472993565860914205758581736963543009081227041107813127348203328487706259288521175996441792477720033391559907463529 = Integer(5552408285910496541614491292546618487277211569377225403191789409528665330891668962031107311064987466753113031830394622471248467736700652061053352988955398236688482161510180819698076352326769666833652868411838404062485515937149953551475970963763214831393011184102640218822580230636796726766349237830849965235421997885866325066652824478670882972960308592442673156948316859355768191060921448605547945438310642985852416679844583683910584162765972403175157909824057369064056749026253300086561085479141352848472993565860914205758581736963543009081227041107813127348203328487706259288521175996441792477720033391559907463529); _sage_const_9508040150448945864896041473620144287185304195373129393945367796278989292111613467431988852136915601924543598539521707867028949117103512086155535622417524652624027120745247788968869035625421925317901537437080516806817665526182101151079627781116996040698696494183565270271640347127907595323550455729314107416504268810895692459900166940308346581854395884953325150692966829621743758974523804744224770947169619202306153219502209841501071805708369725865459063983881721995118160137607226268149638030763856601790923516418230874877537741469843125904517304509697784750516099222207302604420170929688620442534897999896889687325 = Integer(9508040150448945864896041473620144287185304195373129393945367796278989292111613467431988852136915601924543598539521707867028949117103512086155535622417524652624027120745247788968869035625421925317901537437080516806817665526182101151079627781116996040698696494183565270271640347127907595323550455729314107416504268810895692459900166940308346581854395884953325150692966829621743758974523804744224770947169619202306153219502209841501071805708369725865459063983881721995118160137607226268149638030763856601790923516418230874877537741469843125904517304509697784750516099222207302604420170929688620442534897999896889687325); _sage_const_2 = Integer(2); _sage_const_256 = Integer(256); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_72 = Integer(72); _sage_const_30 = Integer(30)#!/usr/bin/env sage

import itertools

# ===================================================================
# Coppersmith small_roots function (as provided)
# ===================================================================
def small_roots(f, bounds, m=_sage_const_1 , d=None):
    if not d:
        d = f.degree()

    if isinstance(f, Polynomial):
        x, = polygens(f.base_ring(), f.variable_name(), _sage_const_1 )
        f = f(x)

    R = f.base_ring()
    N = R.cardinality()

    # NOTE: This line was changed.
    # The original "f /= f.coefficients().pop(0)" assumes the leading
    # coefficient is 1 or invertible. In our resultant, this may not
    # be true. We can skip normalization as LLL is scale-invariant.
    # f /= f.coefficients().pop(0)
    f = f.change_ring(ZZ)

    G = Sequence([], f.parent())
    for i in range(m+_sage_const_1 ):
        base = N**(m-i) * f**i
        for shifts in itertools.product(range(d), repeat=f.nvariables()):
            g = base * prod(map(power, f.variables(), shifts))
            G.append(g)

    B, monomials = G.coefficient_matrix()
    monomials = vector(monomials)

    factors = [monomial(*bounds) for monomial in monomials]
    for i, factor in enumerate(factors):
        B.rescale_col(i, factor)

    B = B.dense_matrix().LLL()

    B = B.change_ring(QQ)
    for i, factor in enumerate(factors):
        B.rescale_col(i, _sage_const_1 /factor)

    H = Sequence([], f.parent().change_ring(QQ))
    for h in filter(None, B*monomials):
        H.append(h)
        I = H.ideal()
        if I.dimension() == -_sage_const_1 :
            H.pop()
        elif I.dimension() == _sage_const_0 :
            roots = []
            for root in I.variety(ring=ZZ):
                root = tuple(R(root[var]) for var in f.variables())
                roots.append(root)
            return roots

    return []

# ===================================================================
# Main Attack Script
# ===================================================================

print("Setting up problem...")

# --- FILL THESE VALUES IN ---
n = _sage_const_11815953932321128728286233763946916083397132728774218853346901896847188062939618033061595326264327830942380514491618514586479068876201765042381540474422687928784286122531623688899920415815956275126678569442393624831728013854407837097172178108695344411448021235738642206171772855890935506373843616183829294338481706967331141381727658274111770236006132024516691250575800075062740745483678936453715236048486953080169036051497290791345433300776845180927261001993504665419670145522848813444443104847339194310622317245742505936802346818589376535066811385405389539543630786953269642690201765952292987472483062982297132627321 
c1 = _sage_const_5552408285910496541614491292546618487277211569377225403191789409528665330891668962031107311064987466753113031830394622471248467736700652061053352988955398236688482161510180819698076352326769666833652868411838404062485515937149953551475970963763214831393011184102640218822580230636796726766349237830849965235421997885866325066652824478670882972960308592442673156948316859355768191060921448605547945438310642985852416679844583683910584162765972403175157909824057369064056749026253300086561085479141352848472993565860914205758581736963543009081227041107813127348203328487706259288521175996441792477720033391559907463529 
c2 = _sage_const_9508040150448945864896041473620144287185304195373129393945367796278989292111613467431988852136915601924543598539521707867028949117103512086155535622417524652624027120745247788968869035625421925317901537437080516806817665526182101151079627781116996040698696494183565270271640347127907595323550455729314107416504268810895692459900166940308346581854395884953325150692966829621743758974523804744224770947169619202306153219502209841501071805708369725865459063983881721995118160137607226268149638030763856601790923516418230874877537741469843125904517304509697784750516099222207302604420170929688620442534897999896889687325 
# ----------------------------

# Define bounds for the small roots r1 and r2
X_bound = _sage_const_2 **_sage_const_256 
Y_bound = _sage_const_2 **_sage_const_256 

# e is known from the problem
e = _sage_const_3 

# === Step 1: Formulate the bivariate polynomial ===

# We need a 3-variable ring (z, x, y) over the Integers to compute the resultant
P_xyz = PolynomialRing(ZZ, names=('z', 'x', 'y',)); (z, x, y,) = P_xyz._first_ngens(3)

P1 = (z + x)**e - c1
P2 = (z + y + _sage_const_1 )**e - c2

# Compute the resultant to eliminate 'z'
# This gives a polynomial R(x, y)
print("Calculating resultant...")
R_xy = P1.resultant(P2, z)
print("Resultant computed.")

# === Step 2: Recover the 256-bit values ===

# Create a polynomial ring in (x, y) modulo n
R_mod_n = PolynomialRing(Integers(n), names=('x', 'y',)); (x, y,) = R_mod_n._first_ngens(2)

# Map our resultant polynomial into this new ring
R_mod_n_xy = R_mod_n(R_xy)

# Call the Coppersmith bivariate attack
# We are looking for roots (r1, r2) such that:
# R_mod_n_xy(r1, r2) == 0 (mod n)
# |r1| < 2^256 and |r2| < 2^256
#
# Tuning m and d might be necessary.
# m=2, d=2 is a good starting point for bivariate.
# The resultant is degree 9, so d=1 might also work.
# Let's try m=2, d=1 (total polynomials = (m+1)*d^n_vars = 3*1^2 = 3... no)
# Let's let d default to f.degree() as in the function
# and start m=1. If that fails, try m=2.
print("Searching for small roots (r1, r2)...")
roots = small_roots(R_mod_n_xy, (X_bound, Y_bound), m=_sage_const_4 )

if not roots:
    print("[-] Coppersmith attack failed to find roots.")
    print("[-] Try increasing 'm' or 'd' in the small_roots call.")
    exit()

# The function returns roots as ZZ_n elements. We need them as integers.
r1, r2 = [Integer(val) for val in roots[_sage_const_0 ]]

print(f"[+] Found r1: {r1}")
print(f"[+] Found r2: {r2}")

# === Step 3: Calculate the polynomial GCD to find the flag ===

# Now we work in a *univariate* ring modulo n
P_z = PolynomialRing(Integers(n), names=('z',)); (z,) = P_z._first_ngens(1)

# Define the two polynomials with our *known* r1 and r2
A = (z + r1)**e - c1
B = (z + r2 + _sage_const_1 )**e - c2

print("Computing GCD to find flag...")
# G = gcd(A, B)
# This fails! Sage does not implement poly GCD over composite rings.
# We must implement the Euclidean algorithm manually.

# A and B are monic cubic, so (A - B) is quadratic.
R1 = A - B

lc_R1 = R1.leading_coefficient()
if lc_R1 == _sage_const_0 :
    print("[-] Error: r1 and r2 are too similar (r1 = r2+1).")
    print("[-] This is highly unlikely, or the (0,0) root is wrong.")
    exit()

try:
    # This checks if the leading coefficient is invertible mod n
    inv_lc_R1 = lc_R1**(-_sage_const_1 )
except ZeroDivisionError:
    print(f"[-] Bad luck! Remainder's leading coefficient ({lc_R1}) is not invertible mod n.")
    print("[-] This means gcd(lc_R1, n) > 1. This is a 'miracle' factorization.")
    print("[-] But it's not what we want. Please re-run the attack with new c1, c2.")
    exit()

# R2 = B % R1
# Since B is cubic and R1 is quadratic, R2 will be linear.
R2 = B % R1

lc_R2 = R2.leading_coefficient()
if lc_R2 == _sage_const_0 :
    # This means R1 divides B, so G = R1 (quadratic).
    # This is bad, we expect a linear GCD.
    print("[-] Error: GCD is not linear (R2's leading coeff is zero).")
    print("[-] This means the (0,0) root is almost certainly wrong.")
    print("[-] Try increasing 'm' or 'd' in small_roots to find the correct (r1, r2).")
    exit()

try:
    inv_lc_R2 = lc_R2**(-_sage_const_1 )
except ZeroDivisionError:
    print(f"[-] Bad luck! Second remainder's leading coefficient ({lc_R2}) is not invertible mod n.")
    print("[-] Please re-run the attack with new c1, c2.")
    exit()

# R3 = R1 % R2
# Since R1 is quadratic and R2 is linear, R3 will be a constant.
# If r1, r2 are correct, A and B share a root, so gcd(A,B) is not 1.
# This means R3 should be 0.
R3 = R1 % R2
if not R3.is_zero():
    print(f"[-] Error: Polynomial remainder R3 is not zero ({R3}).")
    print(f"[-] This means gcd(A, B) is 1 (a constant).")
    print(f"[-] This CONFIRMS the small roots (r1, r2) = ({r1}, {r2}) are WRONG.")
    print(f"[-] The (0, 0) root is spurious. Try increasing 'm' in the small_roots call.")
    exit()

# The last non-zero remainder is R2, which is our GCD.
# We make it monic.
G = R2 * inv_lc_R2
# G should be of the form (z - flag)

print(f"[+] GCD computed: {G}")

# Find the root of the GCD
# .roots() returns (root, multiplicity)
try:
    flag_int = G.roots()[_sage_const_0 ][_sage_const_0 ]
except IndexError:
    print("[-] Error: The GCD polynomial has no roots. This should not happen.")
    exit()

# The root is our flag (as a Z_n element), convert to a Python integer
flag_int = Integer(flag_int)
print(f"[+] Recovered flag (integer): {flag_int}")

# === Step 4: Extract the flag text ===
# (This part is unchanged from your script)

# The flag is 72 bytes, left-shifted by 256 bits
# flag_int = bytes_to_long(flag) << 256
# So, we right-shift by 256 to get the original flag integer
flag_text_int = flag_int >> _sage_const_256 

# Convert the integer back to bytes
# The challenge states the flag is 72 bytes long
flag_len = _sage_const_72 
flag_bytes = flag_text_int.to_bytes(flag_len, byteorder='big')

print("\n" + "="*_sage_const_30 )
print(f"[+] SUCCESS! Flag is: {flag_bytes.decode()}")
print("="*_sage_const_30 )

