# Generated by Gemini Pro

from pwn import *
from Crypto.Util.number import long_to_bytes, bytes_to_long


# Franklin-Reiter formula for e=3, s=1
def recover_m(c1, c2, s, n):
    # m = (c2 + 2*c1 - s**3) * pow(c2 - c1 + 2*s**3, -1, n) % n
    # Simplified for s=1
    if s != 1:
        raise ValueError("This simplified formula only works for s=1")

    # --- THIS IS THE CORRECTED LINE ---
    num = (c2 + 2 * c1 - 1) % n
    # --------------------------------

    den = (c2 - c1 + 2) % n

    if den == 0:
        return None

    try:
        inv_den = pow(den, -1, n)
    except ValueError:  # den is not invertible
        return None

    m = (num * inv_den) % n
    return m


# --- Main Exploit ---

# Connect to the server
r = remote("amt.rs", 33013)
# For a local test:
# r = process(['python', 'chall.py'])

# 1. Get n and e
r.recvuntil(b'n, e = (')
line = r.recvline().decode().strip()
n_str, e_str = line.split(',')  # Had to add a manual fix here
n = int(n_str)
e = int(e_str.rstrip(')'))  # And another manual fix here

print(f"[+] Got n = {n_str[:20]}... (2048 bits)")
print(f"[+] Got e = {e}")

if e != 3:
    print("[!] Exploit failed. e is not 3.")
    exit()

# 2. Collect samples (Birthday Attack)
# k=500 should be sufficient now that the logic is fixed.
k = 500
c_s0 = []  # Ciphertexts for scramble=0
c_s1 = []  # Ciphertexts for scramble=1

print(f"[+] Collecting {k} samples for s=0...")
for _ in range(k):
    r.sendlineafter(b'scramble the flag: ', b'0')
    r.recvuntil(b'c = ')
    c_s0.append(int(r.recvline().decode().strip()))

print(f"[+] Collecting {k} samples for s=1...")
for _ in range(k):
    r.sendlineafter(b'scramble the flag: ', b'1')
    r.recvuntil(b'c = ')
    c_s1.append(int(r.recvline().decode().strip()))

print(f"[+] Collected {len(c_s0)} and {len(c_s1)} samples.")
print(f"[+] Checking {len(c_s0) * len(c_s1)} pairs...")

# 3. Find the matching pair
found_m = None
for c1 in c_s0:
    for c2 in c_s1:
        m = recover_m(c1, c2, 1, n)

        if m is None:
            continue

        # Check if this is the correct m
        if pow(m, 3, n) == c1 and pow(m + 1, 3, n) == c2:
            print("\n[!] Found a valid message pair!")
            found_m = m
            break
    if found_m:
        break

if not found_m:
    print("\n[!] Failed to find a match. Try increasing sample size k.")
    print("[!] (If this still fails, the server might be unstable or k is too low)")
    exit()

print(f"[+] Recovered message m = {str(found_m)[:20]}...")

# 4. Recover the flag from m
P = 2 ** 256
flag_int = found_m >> 256  # Manually simplified this calculation since the AI-generated calculation reassigns r
flag_bytes = long_to_bytes(flag_int)

print("\n" + "=" * 50)
print(f"[*] FLAG: {flag_bytes.decode()}")
print("=" * 50)

r.close()